# 1.阅读-设计模式小册收获总结

## start

- 我现在还记得在多年前的一场面试中，有面试官问到我对设计模式(Design Pattern)有没有了解，使我对设计模式有非常深刻的记忆。
- 今天学习一下。修言编写的 [《JavaScript 设计模式核⼼原理与应⽤实践》](https://juejin.cn/book/6844733790204461070)，说说感受，写写自己的笔记。
- 希望阅读完这篇小册，让我对设计模式有一个初步的认知。
- 2023/02/11--14/20 (星期六)

**设计模式的主要目的：使变化的部分灵活、不变的地方稳定。**

## 构造器模式

在 JavaScript 中，我们使用构造函数去初始化对象，就是应用了构造器模式。

## 工厂模式

工厂模式其实就是**将创建对象的过程单独封装**。

它很像我们去餐馆点菜：比如说点一份西红柿炒蛋，我们不用关心西红柿怎么切、怎么打鸡蛋这些菜品制作过程中的问题，我们只关心摆上桌那道菜。在工厂模式里，我传参这个过程就是点菜，工厂函数里面运转的逻辑就相当于炒菜的厨师和上桌的服务员做掉的那部分工作——这部分工作我们同样不用关心，我们只要能拿到工厂交付给我们的实例结果就行了。

总结一下：工厂模式的目的，就是为了实现**无脑传参**，就是为了爽！

工厂模式的简单之处，在于它的概念相对好理解：将创建对象的过程单独封装，这样的操作就是工厂模式。同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了。

> 对 new 进行封装，然后简化传参，批量生成对象。我们吃饭，只需要点菜，至于买菜炒菜买油等逻辑，我们不必关心。

## 单例模式

**保证一个类仅有一个实例，并提供一个访问它的全局访问点**，这样的模式就叫做单例模式。

> 单例模式，保证类仅有一个实例。例如 vuex。 全局多次注册，但是仅有一个实例

> 简单来说，一个类，保证他只有一个实例，而且能够访问到。
>
> 1.if 判断；2.闭包（返回一个函数，函数的返回值是闭包）

手写单例模式

```js
// 静态方法的形式
class singleDog {
  static getIntance() {
    if (!singleDog.instance) {
      singleDog.instance = new singleDog()
    }

    return singleDog.instance
  }
}

var s1 = singleDog.getIntance()
var s2 = singleDog.getIntance()

console.log(s1, s2, s1 === s2)
```

```js
// 闭包的形式
function singleDog() {}

singleDog.getIntance = (() => {
  let intance = null
  return () => {
    if (!intance) {
      intance = new singleDog()
    }
    return intance
  }
})()

var s1 = singleDog.getIntance()
var s2 = singleDog.getIntance()

console.log(s1, s2, s1 === s2)
```

## 3.原型模式

原型模式不仅是一种设计模式，它还是一种编程范式（programming paradigm），是 JavaScript 面向对象系统实现的根基。

## 4.装饰器模式

装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”。

## 5.适配器模式

适配器模式通过把一个类的接口变换成客户端所期待的另一种接口，可以帮我们解决不兼容的问题。

> 中转的处理函数，然后对接两个接口的不同差异。 例如 axios 中对 XMLHeepRequest/http 的支持。

## 6. 代理模式

代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。

> Proxy

## 7.策略模式

## 8.状态机模式

状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。

状态机模式是对行为做封装，策略模式是对算法进行封装。

## 9.观察者模式

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。
这种发布者直接触及到订阅者的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式。

## 10.迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
